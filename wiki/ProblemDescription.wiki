#summary Elements of a problem description file.

= Problem Description =

Here we discuss the basic items that users have to specify in their input files.

Jump to:
 * [ProblemDescription#Regions regions]
 * [ProblemDescription#Fields_variables_and_integrals fields, variables and integrals]
 * [ProblemDescription#Boundary_conditions boundary conditions]
 * [ProblemDescription#Materials materials]
 * [ProblemDescription#Equations_and_terms equations and terms]
 * [ProblemDescription#Configuring_solvers configuring solvers]

== Regions ==

Regions serve to select a certain part of the computational domain (= selection of nodes and elements of a FE mesh). They are used to define the boundary conditions, the domains of terms and materials etc.

 * Region selection syntax:

  Entity selections:
    * all
    * nodes of surface
    * nodes in <expr>
    * nodes by <function>
    * node <id>
    * elements of group <integer>
    * elements by <efunction>
    * r.<name of another region>

  Notation:
    * <expr> is a logical expression like {{{(y <= 0.00001) & (x < 0.11)}}}
    * <function> is e.g. {{{afunction( x, y, z, otherArgs )}}}
    * <efunction> is e.g. {{{efunction( domain )}}}

  Region operations:
    * node-wise: {{{+n, -n, *n}}} (union, set difference, intersection)
    * element-wise: {{{+e, -e, *e}}} (union, set difference, intersection)

 * Region definition syntax:

   Long syntax: a region is defined by the following dictionary ([] denote optional keys):

   {{{
region_<number> = {
    'name' : <string>,
    'select' : <selection string>,
    ['forbid'] : group <integer>[, <integer>]* # forbid elements of listed groups
    ['can_cells'] : <boolean> # determines whether a region can have cells (volume in 3D)
}
   }}}

   Example definitions:

   {{{
    region_20 = {
        'name' : 'Left',
        'select' : 'nodes in (x < -0.499)'
    }
    region_21 = {
        'name' : 'Right',
        'select' : 'nodes in (x > 0.499)'
    }
    region_31 = {
        'name' : 'Gamma1',
        'select' : """(elements of group 1 *n elements of group 4)
                      +n
                      (elements of group 2 *n elements of group 4)
                      +n
                      ((r.Left +n r.Right) *n elements of group 4)
                   """,
        'forbid' : 'group 1 2'
    }
   }}}

   Example definitions, short syntax:

   {{{
    regions = {
        'Left' : ('nodes in (x < -0.499)', {}),
        'Right' : ('nodes in (x > 0.499)', {}),
        'Gamma1' : ("""(elements of group 1 *n elements of group 4)
                       +n
                       (elements of group 2 *n elements of group 4)
                       +n
                       ((r.Left +n r.Right) *n elements of group 4)""",
                     {'forbid' : 'group 1 2'}),
    }
   }}}

== Fields variables and integrals ==
 * fields correspond to FE spaces
   * example: P1 elements in 2D on a whole domain Omega
 {{{
 field_1 = {
    'name' : 'temperature',
    'dim' : (1,1),
    'domain' : 'Omega',
    'bases' : {'Omega' : '2_3_P1'}
}
 }}}
 * variables use the FE approximation given by the specified field:
   * example, long syntax:
{{{
variable_1 = {
    'name' : 't',
    'kind' : 'unknown field',
    'field' : 'temperature',
    'order' : 0, # order in the global vector of unknowns
}

variable_2 = {
    'name' : 's',
    'kind' : 'test field',
    'field' : 'temperature',
    'dual' : 't',
}
}}}
   * example, short syntax:
{{{
variables = {
    't' : ('unknown field', 'temperature', 0),
    's' : ('test field', 'temperature', 't'),
}
}}}
 * integrals (quadrature rules):
 {{{
integral_1 = {
    'name' : 'i1',
    'kind' : 'v',
    'quadrature' : 'gauss_o2_d2', # <quadrature name>
}

import numpy as nm
N = 2
integral_2 = {
    'name' : 'i2',
    'kind' : 'v',
    'quadrature' : 'custom', # <quadrature name>
    'vals'    : zip(nm.linspace( 1e-10, 0.5, N ),
                    nm.linspace( 1e-10, 0.5, N )),
    'weights' : [1./N] * N,
}
 }}}
  * available quadratures are in sfe/fem/quadratures.py - it is still preliminary and incomplete
  * naming convention: <family>_o<order>_d<dimension>

== Boundary conditions ==

 * Dirichlet (essential) boundary conditions, long syntax:
{{{
ebc_<number> = {
    'name' : <string>,
    'region' : <region_name>,
    'dofs' : {<dof_specification> : <value>[,
              <dof_specification> : <value>, ...]}
}
}}}
  * example:
{{{
ebc_1 = {
    'name' : 'ZeroSurface',
    'region' : 'Surface',
    'dofs' : {'u.all' : 0.0, 'phi.all' : 0.0},
}
}}}
 * Dirichlet (essential) boundary conditions, short syntax:
{{{
ebcs = {
    'name' : (<region_name>, {<dof_specification> : <value>[,
                              <dof_specification> : <value>, ...]},...}
}
}}}
  * example:
{{{
ebcs = {
    'u1' : ('Left', {'u.all' : 0.0}),
    'u2' : ('Right', {'u.0' : 0.1}),
    'phi' : ('Surface', {'phi.all' : 0.0}),
}
}}}
}}}

== Materials ==

TODO

== Equations and terms ==

Equations can be built by combining terms listed in [http://sfepy.googlecode.com/svn/web/docs/sfepy_manual.pdf sfepy_manual.pdf].

Examples:

  * Laplace equation:
{{{
equations = {
    'Temperature' : """dw_laplace.i1.Omega( coef.val, s, t ) = 0"""
}
}}}
 * Navier-Stokes equations:
{{{
equations = {
    'balance' :
    """+ dw_div_grad.i2.Omega( fluid.viscosity, v, w )
       + dw_convect.i2.Omega( v, w )
       - dw_grad.i1.Omega( v, r ) = 0""",
    'incompressibility' :
    """dw_div.i1.Omega( q, w ) = 0""",
}
}}}

== Configuring solvers ==

TODO
