#summary A beginner's tutorial on using SfePy.

= Introduction =

Welcome to this primer on SfePy. To get you started, a step-by-step walk-through of the process to solve a simple mechanics problem is presented. The typical process to solve a problem using SfePy is followed: a model is meshed, a problem definition file is drafted, SfePy is run to solve the problem and finally the results of the analysis are illustrated. 


== Problem statement ==

A popular test to measure the tensile strength of concrete or asphalt materials is the indirect tensile strength test pictured below.  

http://groups.google.com/group/sfepy-devel/web/ITS.png

In this test a circular cylindrical specimen is loaded across its diameter to failure. The test is usually done by loading the specimen at a constant deformation rate of 50 mm/minute (say) and measuring the load response. When the tensile stress that develops in the specimen under loading exceeds its tensile strength then the specimen will fail. To model this problem using finite elements the indirect tensile test can be simplified to represent a diametrically point loaded disk as shown below.    

http://groups.google.com/group/sfepy-devel/web/ITS2D.png

The tensile and compressive stresses that develop in the centre of the specimen as a result of the point loads P are a function of the diameter (D) and thickness (t) of the cylindrical specimen. These are, respectively:

<wiki:gadget url="http://mathml-gadget.googlecode.com/svn/trunk/mathml-gadget.xml" border="0" up_content="sigma_{t} = (2 cdot P) / (pi cdot t cdot D)"/> 

<wiki:gadget url="http://mathml-gadget.googlecode.com/svn/trunk/mathml-gadget.xml" border="0" up_content="sigma_{c} = (6 cdot P) / (pi cdot t cdot D)"/>

These solutions may be approximated using finite element analyses. To solve this problem using SfePy the first step is meshing a suitable model.

= Meshing = 

Assuming plane strain conditions, the indirect tensile test may be modeled using a 2-D finite element mesh. Furthermore, the geometry of the model is symmetrical about the x- and y-axes passing through the centre of the circle. To take advantage of this symmetry only one quarter of the 2-D model will be meshed and boundary conditions will be established to indicate this symmetry. The meshing program Gmsh is used in this tutorial to very quickly mesh the model.

The indirect tensile test specimen has a diameter of 150 mm. Using Gmsh add three new Points (geometry elementary entities) at the following coordinates:
(0.0 0.0), (75.0,0.0) and (0.0,75.0). Next add two straight lines connecting the points as shown below.

http://groups.google.com/group/sfepy-devel/web/mesh1.png

Next add a Circle arc connecting two of the points to form the quarter circle segment.

http://groups.google.com/group/sfepy-devel/web/mesh2.png 

Still under Geometry add a Ruled surface.

http://groups.google.com/group/sfepy-devel/web/mesh3.png  
   

With the geometry of the model defined, add a mesh by clicking on the 2D button under the Mesh functions.

http://groups.google.com/group/sfepy-devel/web/mesh4.png

That's it, we're done with the meshing. Save the mesh in a format that SfePy recognizes. For now use the medit .mesh format e.g. its2D.mesh. (Hint: check the drop down in the _Save As_ dialog for the different formats Gmsh can save to) 

If you open the its2D.mesh file using a text editor you'll notice that Gmsh saves the mesh in a 3-D format and includes some extra geometry items that we can delete. I've reformatted the mesh file to a 2-D format and deleted the _Edges_ block. Note that when you do this the file cannot be reopened by Gmsh so it is always a good idea to also save your meshes in Gmsh's native format as well (Shift-Ctrl-S). Click on the following link to download the reformatted mesh file that will be used in the tutorial.

http://groups.google.com/group/sfepy-devel/web/its2D.mesh
    

You'll notice that the mesh contains 55 vertices (nodes) and 83 triangle elements. The mesh file provides the coordinates of the nodes and the element connectivities. It is important to note that node and element numbering in SfePy start at 0 and not 1 as is the case in Gmsh and other meshing programs. For example, a demo version of medit can be downloaded from the following site:

http://www.ann.jussieu.fr/~frey/software.html

After loading your mesh file with medit you can see the node and element numbering by pressing P and F respectively. The numbering in medit starts at 1. Node and element numbers can also be viewed in Gmsh - under the mesh option under the Visibility tab enable the node and surface labels. Note that the surface labels as numbered in Gmsh follow on from the line numbering. So to get the corresponding element number in SfePy you'll need to subtract the number of lines in the Gmsh file + 1. Confused yet? Luckily, SfePy provides some useful mesh functions to indicate which elements are connected to which nodes. Nodes and elements can also be identified by defining regions - but more on this later.   

The next step in the process is developing the SfePy problem definition file.

= Problem description =

The programming of the problem description file is well documented in the [http://docs.sfepy.org/doc/users_guide.html SfePy user's guide]. The problem description file used in the tutorial can be downloaded here:

http://groups.google.com/group/sfepy-devel/web/its2D_1.py

Download and open the file in your favorite python editor. Note that you will need to change the location of the output directory to somewhere on your drive. For the analysis we will assume that the material of the test specimen is linear elastic and isotropic. We define two material constants i.e. Young's modulus and Poisson's ratio. The material is assumed to be asphalt concrete having a Young's modulus of 2,000 MPa and a Poisson's ration of 0.4. 

Note - be consistent in your choice and use of units. In the tutorial we are using Newton (N), millimeters (mm) and megaPascal (MPa).

The following block of code defines regions on your mesh: 
{{{
regions = {
    'Omega' : ('all', {}),
    'Left' : ('nodes in (x < 0.001)', {}),
    'Bottom' : ('nodes in (y < 0.001)', {}),
    'Top' : ('node 2', {}),
}
}}}  

Four regions are defined:
  # Omega: all the elements in the mesh
  # Left: the y-axis
  # Bottom: the x-axis
  # Top: the topmost node. This is where the load is applied.

Having defined the regions these can be used in other parts of your code. For example, consider the definition of the asphalt material:

{{{
materials = {
    'Asphalt' : ('Omega', {
        'lam' : youngpoisson_to_lame(young, poisson)[0],
        'mu' : youngpoisson_to_lame(young, poisson)[1],
    }),
}
}}} 

Since the material is defined on Omega it applies to the entire model. We provided the material constants in terms of Young's modulus and Poisson's ration, but the linear elastic isotropic equation used requires as input Lamé’s parameters. The _youngpoisson_to_lame_ function is thus used for conversion. Note that to use this function it was necessary to import the function into the code, which was done up front:

{{{
from sfepy.mechanics.matcoefs import youngpoisson_to_lame
}}}   

Check out [http://docs.sfepy.org/doc-devel/src/sfepy/mechanics/matcoefs.html the sfepy.mechanics.matcoefs module] for other useful functions.

The boundary conditions are defined as follows:

{{{
ebcs = {
    'XSym' : ('Bottom', {'u.1' : 0.0}),
    'YSym' : ('Left', {'u.0' : 0.0}),
    'Load' : ('Top', {'u.0' : 0.0, 'u.1' : -1.0}),
}
}}}

Now the power of the regions entity becomes apparent. To ensure symmetry about the x-axis, the vertical or y-displacement of the nodes in the _Bottom_ region are prevented or set to zero. Similarly, for symmetry about the y-axis, any horizontal or displacement in the x-direction of the nodes in the _Left_ region or y-axis is prevented. Finally, to indicate the response of the load, the topmost node (number 2) is given a displacement of 1 mm downwards in the vertical or y-direction and displacement of this node in the x-direction is restricted.

That's it - we are now ready to solve the problem.

= Running SfePy =  

One option to solve the problem is to run the SfePy _simple.py_ script from the command shell:

{{{
  $ ./simple.py its2D_1.py
}}}

For the purpose of this tutorial it is assumed that the problem definition file (its2D_1.py) is in the same directory as the _simple.py) script. If you have the _its2D_1.py_ file in another directory then make sure you include the path to this file as well. 

SfePy solves the problem and outputs the solution to the output path (output_dir) provided in the script. The output file will be in the format you specified (in our case, vtk) and the name of the output file will be the same as that used for the mesh file except with the vtk extension i.e. its2D.vtk.

The vtk format is an ascii format. Open the file using a text editor. You'll notice that the output file includes separate sections:
  * POINTS (these are the model nodes)
  * CELLS (the model element connectivity)
  * VECTORS (the node displacements in the x-, y- and z- directions.
        
Notice that the y-displacement of node 2 is -1.0 as we set it as a boundary condition. 

SfePy includes a script (_postproc.py_) to quickly view the solution. To run this script you need to have [http://code.enthought.com/projects/mayavi/docs/development/html/mayavi/index.html Mayavi] installed. From the command line issue the following (with the correct paths):

{{{
  $ ./postproc.py its2D.vtk
}}} 

The solution will be displayed as follows:

http://groups.google.com/group/sfepy-devel/web/its2D_1.png

The figure shows the average displacements in the model but we are more interested in the stresses. To get these we need to modify the problem description file.    

= Post-processing =

SfePy provides functions to calculate stresses and strains. We'll include a function to calculate these and update the problem material definition and options to call this function as a _post_process_hook_. Save this file as [http://groups.google.com/group/sfepy-devel/web/its2D_2.py its2D_2.py]. 

{{{
from its2D_1 import *

from sfepy.mechanics.matcoefs import stiffness_tensor_youngpoisson

def stress_strain(out, pb, state, extend = False):
    '''
    Calculate and output strain and stress for given displacements.
    '''
    from sfepy.base.base import Struct
    from sfepy.fem.evaluate import eval_term_op

    strain = eval_term_op(state, 'de_cauchy_strain.i1.Omega(u)', pb)
    stress = eval_term_op(state, 'de_cauchy_stress.i1.Omega(Asphalt.D,u)', pb)

    out['cauchy_strain'] = Struct(name = 'output_data', mode = 'cell', data = strain, dofs = None)
    out['cauchy_stress'] = Struct(name = 'output_data', mode = 'cell', data = stress, dofs = None)

    return out

materials['Asphalt'][1].update({'D' : stiffness_tensor_youngpoisson(2, young, poisson)})

options.update({'post_process_hook' : 'stress_strain',})
}}}

The updated file imports all of the previous definitions in _its2D_1.py_. The stress function (_de_cauchy_stress_) requires as input the stiffness tensor - thus it was necessary to update the materials accordingly. The problem options were also updated to call the stress_strain function as a _post_process_hook_.

Run SfePy to solve the updated problem and view the solution (assuring the correct paths):

{{{
  $ ./simple.py its2D_2.py   
  $ ./postproc.py its2D.vtk
}}}

In addition to the node displacements, the vtk output now also includes the stresses and strains averaged in the elements:

http://groups.google.com/group/sfepy-devel/web/its2D_2.png

Remember the objective was to determine the stresses at the centre of the specimen under a load P. The solution as currently derived is expressed in terms of a global displacement vector (u). The global (residual) force vector (f) is a function of the global displacement vector and the global stiffness stiffness matrix (K) as: f = Ku.  

In addition to solving problems using the _simple.py_ script you can also run SfePy interactively. This requires that [http://ipython.scipy.org/moin/ ipython] be installed. To run SfePy interactively, run the following command:

{{{
  $ ./isfepy
}}}

Once isfepy loads up, issue the following command:

{{{
In [1]: pb,vec,data=pde_solve('its2D_2.py')
}}}

The problem is solved and the problem definition and solution are provided in the _pb_ and _vec_ variables - see for yourself:

{{{
In [2]: pb
Out[2]: ProblemDefinition

In [3]: vec
Out[3]: 
array([ 0.        ,  0.        ,  0.22608933, ..., -0.12051821,
        0.05335311, -0.0677574 ])

}}}

_vec_ is a [http://numpy.scipy.org/ NumPy] array. If an array is too large to be printed then NumPy automatically skips the central part of the array and only prints the corners. To disable this behaviour and force NumPy to print the entire array, you can change the printing options using _set_printoptions_:

{{{
In [4]: nm.set_printoptions(threshold=nm.nan)

In [5]: vec
Out[5]: 
array([  0.00000000e+00,   0.00000000e+00,   2.26089335e-01,
         0.00000000e+00,   0.00000000e+00,  -1.00000000e+00,
         6.63971215e-02,   0.00000000e+00,   1.24441304e-01,
         0.00000000e+00,   1.70385399e-01,   0.00000000e+00,
         1.99298768e-01,   0.00000000e+00,   2.18582169e-01,
         0.00000000e+00,   2.25796244e-01,   0.00000000e+00,
         0.00000000e+00,  -8.79805516e-02,   0.00000000e+00,
        -1.82185927e-01,   0.00000000e+00,  -2.80990423e-01,
         0.00000000e+00,  -4.00595135e-01,   0.00000000e+00,
        -5.50110472e-01,   0.00000000e+00,  -7.45248105e-01,
         2.27070400e-01,  -2.04441298e-04,   2.20041801e-01,
        -3.26787845e-03,   2.05201142e-01,  -1.09412111e-02,
         1.80098205e-01,  -2.65392990e-02,   1.55431639e-01,
        -4.82843331e-02,   1.28652055e-01,  -7.93731154e-02,
         9.21889931e-02,  -1.32683205e-01,   6.48084676e-02,
        -2.15748378e-01,   5.64208432e-02,  -3.47335767e-01,
         6.06872070e-02,  -5.38055540e-01,   1.09511997e-01,
        -3.36581071e-01,   1.40791478e-01,  -1.43717901e-01,
         1.65544415e-01,  -7.99009303e-02,   7.60332236e-02,
        -3.05735492e-01,   1.94131192e-01,  -3.14738683e-02,
         1.86892641e-01,  -7.27770330e-02,   8.91897463e-02,
        -1.91994617e-01,   1.54623330e-01,  -4.60437943e-02,
         1.20254408e-01,  -1.12774894e-01,   1.09504925e-01,
        -4.70318595e-02,   1.77917973e-01,  -1.08193881e-01,
         1.83995155e-01,  -5.65245956e-02,   1.57499020e-01,
        -1.70118441e-01,   1.69618983e-01,  -8.18631674e-02,
         1.22044326e-01,  -2.11011757e-01,   2.16704241e-01,
        -2.09744554e-02,   2.13139411e-01,  -1.95199341e-02,
         7.60146118e-02,  -4.95813366e-01,   2.00891096e-01,
        -5.18626156e-02,   2.24565301e-01,  -7.60322658e-03,
         1.31618167e-01,  -2.57287456e-01,   7.84055846e-02,
        -3.93575270e-01,   2.01032828e-01,  -4.07244993e-02,
         1.51756670e-01,  -1.71585144e-01,   9.14563247e-02,
        -2.76913189e-01,   1.30598428e-01,  -2.24890151e-01,
         1.39613746e-01,  -1.35535326e-01,   5.27252944e-02,
        -1.39543341e-01,   1.67805867e-01,  -1.20518214e-01,
         5.33531054e-02,  -6.77573971e-02])

In [6]: vec.shape
Out[6]: (110,)
}}}  

So _vec_, the global displacement vector, holds the x- and y-displacements at the 55 nodes in the model.

The global stiffness matrix is saved in _pb_:

{{{
In [7]: print pb.mtx_a
------> print(pb.mtx_a)
  (0, 0)	2443.95959851
  (0, 6)	-2110.99917491
  (0, 13)	-332.960423597
  (0, 14)	1428.57142857
  (1, 1)	4048.78343529
  (1, 2)	-1354.87004384
  (1, 51)	-609.367453538
  (1, 52)	-1869.0018791
  (1, 91)	-357.41672785
  (1, 92)	1510.24654193
  (2, 1)	-1354.87004384
  (2, 2)	4121.03202907
  (2, 3)	-1696.54911732
  (2, 47)	76.2400806561
  (2, 48)	-1669.59247304
  (2, 51)	-1145.85294856
  (2, 52)	2062.13955556
  (3, 2)	-1696.54911732
  (3, 3)	4410.17902905
  (3, 4)	-1872.87344838
  (3, 41)	-130.515009576
  (3, 42)	-1737.33263802
  (3, 47)	-710.241453776
  (3, 48)	1880.20135513
  (4, 3)	-1872.87344838
  :	:
  (90, 80)	-1610.0550578
  (90, 85)	-199.343680224
  (90, 86)	-2330.41406097
  (90, 89)	-575.80373408
  (90, 90)	7853.23899229
  (91, 1)	-357.41672785
  (91, 7)	1735.59411191
  (91, 49)	-464.976034459
  (91, 50)	-1761.31189004
  (91, 51)	-3300.45367361
  (91, 52)	1574.59387937
  (91, 87)	-250.325600254
  (91, 88)	1334.11823335
  (91, 91)	9219.18643706
  (91, 92)	-2607.52659081
  (92, 1)	1510.24654193
  (92, 7)	-657.361661955
  (92, 49)	-1761.31189004
  (92, 50)	54.1134516246
  (92, 51)	1574.59387937
  (92, 52)	-315.793227627
  (92, 87)	1334.11823335
  (92, 88)	-4348.13351285
  (92, 91)	-2607.52659081
  (92, 92)	9821.16012014

In [8]: pb.mtx_a.shape
Out[8]: (93, 93)
}}}  




*Still under construction - check back later*